TDD: класс вектора
##################

:date: 2016-10-19 20:10
:lecture_link: https://youtu.be/1A4MrIfVMTI

.. default-role:: code
.. contents:: Содержание

Введение
========

В курсе, посвящённом языку Python, было `рассмотрен`__ вопрос тестирования программ. Все изложенные идеи при помощи
минимальных изменений, касающихся непосредственно использования конкретной библоиотеки для тестирования, могут быть
применены по сути к любому языку программирования. В этой работе мы рассмотрим процесс модульного
тестирования программ, написанных на языке C++.

.. __: http://judge.mipt.ru/mipt_cs_on_python3_2015/labs/lab6.html#id9

Разработка через тестирование
=============================

Одним из распросстранённых подходов к написанию программ вляется подход под названием **«Test-driven development»**
(TDD, разработка через тестирование). Суть этого подхода заключается в том, что **перед** непосредственным написанием
функциональных частей программы пишутся тесты, которые фиксируют интерфейс взаимодействия, а также описывают ожидаемое
поведение. После того, как написаны тесты, начинается процесс написания основной программы, которая считается законченной, когда все тесты успешно  пройдены.

В качестве примера рассмотрим следующий фрагмент:

.. code-block:: cpp

    vector3d v1 = {1, 2, 3};
    vector3d v2 = {1, 2, 3};

    bool test1 = (v1 == v2) && !(v1 != v2);
    assert(test1);

    vector3d v3 = v1 + v2;
    bool test2 = v3 == vector3d(2, 4, 6);
    assert(test2);

    vector3d v4 = v1 - v2;
    bool test3 = v3 == vector3d(0, 0, 0);
    assert(test3);

    vector3d v5;

    bool test4 = v5 == vector3d(0, 0, 0);
    assert(test4);


Несмотря на то, что мы пока даже не знаем, что из себя представляет класс `vector3d`, мы уже можем сделать достаточно большое количество выводов о нём:

.. code-block:: cpp

    // 0. Класс представляет собой реализацию трёхмерного вектора

    // 1. Класс имеет конструктор, который принимает три параметра
    vector3d v1 = {1, 2, 3};
    vector3d v2 = {1, 2, 3};

    // 2. Для класса определены операторы == и != для проверки равенства и неравенства векторов
    bool test1 = (v1 == v2) && !(v1 != v2);
    assert(test1);

    // 3. Для класса определены операторы + и - для выполнения векторного сложения и вычитания
    vector3d v3 = v1 + v2;
    bool test2 = v3 == vector3d(2, 4, 6);
    assert(test2);

    vector3d v4 = v1 - v2;
    bool test3 = v3 == vector3d(0, 0, 0);
    assert(test3);

    // 4. Класс имеет конструктор по умолчанию, который инициализирует вектор нулями
    vector3d v5;

    bool test4 = v5 == vector3d(0, 0, 0);
    assert(test4);

Как мы видим, не любая реализацию класса `vector3d` будет удовлетворять требованиям, описанным выше. Именно это и
подразумевается под фиксацией интерфейса взаимодействия: тесты описывают, **как** именно мы собираемся использовать
класс и **какое** поведение ожидаем от класса.


Библиотека Google Test
======================

Существует большое количество библиотек для тестирования программ, написанных на языке C++ (`CxxTest`__, `QTest`__,
`Boost::Test`__ и др.). В этой работе мы будем использовать библиотеку `Google Test`__.

.. __: http://cxxtest.tigris.org/
.. __: http://doc.qt.io/qt-5/qtest.html
.. __: http://www.boost.org/doc/libs/1_40_0/libs/test/doc/html/index.html
.. __: https://github.com/google/googletest

Эта библиотека предоставляет набор макросов (а также функций и классов) для написания модульных тестов. Рассмотрим
пример написания модульного теста с использованием `Google Test`:

.. code-block:: cpp

   // Подключаем заголовочный файл
   #include <gtest/gtest.h>
   
   // Описываем тест
   // Sample1 — группа, к которой относится тест
   // TestThatPasses — название теста
   //
   // Имя группы название и теста должны быть валидными идентификаторами,
   // при этом они не могут содержать символ подчёркивания.
   // Группа указывается для логического объединения «близких» тестов.
   TEST(Sample1, TestThatPasses)
   {
       // Выполняем проверки при помощи макросов ASSERT_*
       // Все проверки ниже будут успешно пройдены
   
       ASSERT_TRUE(true);
       ASSERT_FALSE(false);
   
       ASSERT_EQ(1, 1);
       ASSERT_EQ("123", "123");
   
       ASSERT_NE(1, 2);
   
       ASSERT_FLOAT_EQ(1.0, 1.0);
   
       ASSERT_LE(1, 2);
       ASSERT_LE(2, 2);
   
       ASSERT_GE(2, 1);
       ASSERT_GE(2, 2);
   }
   
   // Описываем ещё один тест
   TEST(Sample2, TestThatFails)
   {
       // Выполняем проверки при помощи макросов ASSERT_*
       
       ASSERT_FALSE(false);
       // Эта проверка не будет пройдена
       ASSERT_FALSE(true);
   }
   
   int main(int argc, char* argv[])
   {
       // Запускаем все тесты на исполнение
       testing::InitGoogleTest(&argc, argv);
       return RUN_ALL_TESTS();
   }

Вывод программы из примера:

.. code-block:: text

   [==========] Running 2 tests from 2 test cases.
   [----------] Global test environment set-up.
   [----------] 1 test from Sample1
   [ RUN      ] Sample1.TestThatPasses
   [       OK ] Sample1.TestThatPasses (0 ms)
   [----------] 1 test from Sample1 (0 ms total)
   
   [----------] 1 test from Sample2
   [ RUN      ] Sample2.TestThatFails
   /home/student/lab8/gtest_sample.cpp:40: Failure
   Value of: true
     Actual: true
   Expected: false
   [  FAILED  ] Sample2.TestThatFails (0 ms)
   [----------] 1 test from Sample2 (0 ms total)
   
   [----------] Global test environment tear-down
   [==========] 2 tests from 2 test cases ran. (0 ms total)
   [  PASSED  ] 1 test.
   [  FAILED  ] 1 test, listed below:
   [  FAILED  ] Sample2.TestThatFails
   
    1 FAILED TEST

Ниже приведён список небольшой части макросов `ASSERT_*`, которые предоставляет библиотека `Google Test`. Схема работы
всех макросов одинакова: в случае, если утверждение, описываемое макросом, ложно, то геренируется исключение, а тест
помечается как проваленный.

+------------------------------+--------------------------------------------+
| Макрос                       | Эквивалентное утверждение                  |
+==============================+============================================+
| ASSERT_TRUE(v);              | v == true                                  |
+------------------------------+--------------------------------------------+
| ASSERT_FALSE(v);             | v == false                                 |
+------------------------------+--------------------------------------------+
| ASSERT_EQ(val1, val2);       | val1 == val2                               |
+------------------------------+--------------------------------------------+
| ASSERT_NE(val1, val2);       | val1 != val2                               |
+------------------------------+--------------------------------------------+
| ASSERT_LT(val1, val2);       | val1 < val2                                |
+------------------------------+--------------------------------------------+
| ASSERT_LE(val1, val2);       | val1 <= val2                               |
+------------------------------+--------------------------------------------+
| ASSERT_GT(val1, val2);       | val1 > val2                                |
+------------------------------+--------------------------------------------+
| ASSERT_GE(val1, val2);       | val1 >= val2                               |
+------------------------------+--------------------------------------------+
| ASSERT_FLOAT_EQ(val1, val2); | val1 == val2 // с учётом ошибок округления |
+------------------------------+--------------------------------------------+


Класс вектора
=============

Цель данной работы — написать класс вектора, который будет удовлетворять всем требованиям, заданным при помощи заранее
написанных тестов. Порядок выполнения работы:

#. Сделайте форк `репозитория`__, который содержит заготовку для работы.
#. Склонируйте получившийся  репозиторий.
#. В файлах `vector3d.hpp`__ и `vector3d.cpp`__  склонированного репозитория допишите реализацию класса вектора, для 
   которой будут проходить все тесты, описанные в файле `vector_tests.cpp`__. К классу вектора предъявляются следующие
   требования:

   * наличие конструктора с параметрами;
   * наличие конструктора по-умолчанию;
   * возможность прямого доступа к полям;
   * поддержка векторного сложения и вычитания;
   * поддержка векторного умножения;
   * поддержка скалярного умножения;
   * поддержка операции умножения на скаляр;
   * наличие метода для вычисления длины;
   * наличие метода для нормализации;
   * поддержка операций проверки равенства и неравенства;
   * наличие перегруженного оператора для вывода в `std::ostream`.

.. __: https://github.com/mipt-cs-on-cpp/vector3d
.. __: https://github.com/mipt-cs-on-cpp/vector3d/blob/master/vector3d.hpp
.. __: https://github.com/mipt-cs-on-cpp/vector3d/blob/master/vector3d.cpp
.. __: https://github.com/mipt-cs-on-cpp/vector3d/blob/master/vector_tests.cpp

